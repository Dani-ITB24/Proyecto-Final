# **Índice**

<span style="color:black;">1. [ Enumeración](#Enumeración)</span><br>
<span style="color:black;">2. [ Buscar vulnerabilidades](#Vulnerabilidades)</span><br>
<span style="color:black;">3. [ Flag user.txt](#Flag1)</span><br>
<span style="color:black;">4. [ Movimiento lateral](#Movimiento)</span><br>
<span style="color:black;">5. [ Escalada de privilegios a Root](#Escalada)</span><br>
<span style="color:black;">6. [ Flag de Root](#flag-root)</span><br>
---

<br>

<h1 name="Enumeración">1. Enumeración</h1>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/nmap.png" alt="nmap">

> nmap -sVC -v -p- 172.17.0.2 
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/gobuster.png" alt="gobuster">

> gobuster dir -u http://172.17.0.2/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/web-principal.png" alt="web">
Al acceder a la IP de la máquina en el navegador nos encontramos un validador de URLs. Vamos a intentar ver que hay por detrás.
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/web-principal.html.png" alt="web-html">
Bien, al parecer, el formulario envía la información a un archivo .php, vamos a probar que pasa cuando enviamos algo en el formulario.
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/google-validator.png" alt="google">
Lo que hace esta web es enviar una petición a la URL que le pasemos y nos muestra el resultado gráfico. Así evitamos acceder a webs que puedan ser maliciosas ya que la web lo hace por nosotros.
Vamos a probar de entrar en el directorio /admin que hemos descubierto con el Gobuster anteriormente.
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/admin.png" alt="admin">
Tenemos un login. Vamos a ver como funciona.
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/admin.html.png" alt="admin-html">
Si probamos a enviar el formulario la página no hará ningún cambio y veremos los datos en la URL (GET). Observando el código fuente de la página podemos observar que está a medio hacer, aquí no tenemos nada de que hacer así que vamos a probar acceder al puerto 5000, que hemos visto que tenia un Apache por detrás.
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/web5000.html.png" alt="5000-html">
Al acceder nos sale un mensaje de acceso denegado. Si miramos el código fuente vemos que no hay nada. Vamos a probar a hacer una petición con curl a ver que nos devuelve.
<br>

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/curl-web5000.png" alt="curl">
Con curl nos devuelve también el mismo HTML que antes. Solo nos queda la web de verificador de URL. A ver que podemos sacar de ahí.
<br>

<h1 name="Vulnerabilidades">2. Buscar vulnerabilidades</h1>
Para poder conseguir mas información del servidor intentaremos realizar un ataque SSRF, para ello modificaremos la petición realizada a la web que valida URL para que en vez de validar Google realice una petición a localhost.

> 172.17.0.2/info.php?url=http%3A%2F%2Flocalhost%3A5000

Una vez hemos realizado el SSRF podemos ver una web que parece estar en desarrollo.
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ssrf1.png" alt="en desarrollo">
Si utilizamos las herramientas de desarrollador de nuestro navegador podremos inspeccionar el código HTML. Encontramos los siguientes mensajes. 
**Paco cambia tu contraseña, es muy débil y podría ser peligroso**
**Francisca, tu actualiza la página de desarrollo y pon nuestro logo**
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/inspeccionarindex5000.png" alt="inspeccionar index">

Podemos sacar en claro que hay dos usuarios en el servidor, Paco y Francisca. Paco tiene una contraseña débil, intentamos descubrirla con fuerza bruta usando **hydra**.
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/hydra_paco.png" alt="hydra_paco">

<br>


<h1 name="Flag1">3. Flag user.txt</h1>
Utilizando la contraseña de Paco podremos acceder al servidor a través de SSH.

<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/sshpaco.png" alt="ssh paco">

En la home de Paco podemos encontrar la primera flag user.txt
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ls_home_paco.png" alt="ls_home_paco">


<h1 name="Movimiento">4. Movimiento lateral</h1>
Tras realizar varias pruebas confirmamos que desde el usuario Paco no podemos hacer nada mas. Para poder escalar a root tendremos que acceder como usuario Francisca al servidor. Como ya sabemos hay un servicio SSH funcionando en el servidor, intentaremos encontrar las claves ssh de Francisca.
En la salida del comando find podemos encontrar un directorio inusual en /usr llamada sshkeys.
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/find_sshkeys.png" alt="findsshkeys">
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/find_sshkeys2.png" alt="findsshkeys2">

Dentro de este directorio podemos encontrar una clave SSH privada, si realizamos un listado del directorio podemos ver que el grupo propietario es dbadmin, también podemos ver que Francisca forma parte de dbadmin.
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ls_sshkeys.png" alt="ls_sshkeys"><br>
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/dbadmin.png" alt="dbadmin"><br>
<img src="https://github.com/Dani-ITB24/Proyecto-Final/blob/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/cat_idrsa.png" alt="cat_idrsa"><br>

Podemos suponer que esta clave SSH es la clave privada de Francisca. Copiaremos esta clave a un archivo que llamaremos **id_rsajohn** para poder descubrir la passphrase que se ha utilizado para securizar la clave primero tendremos que utilizar el comando **ssh2john** para poder generar un hash que después descifraremos usando **john the reaper**
<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ssh2john.png" alt="ssh2john">
<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/john_rsa_francisca.png" alt="John Francisca RSA">

Hemos descubierto la passphrase utilizada para la clave SSH de Francisca, **laracroft**.
Utilizando esta clave podremos conectarnos a través de ssh al usuario Francisca utilizando la opción **-i**.

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ssh_id_rsa_francisca.png" alt="SSH -i francisca">

<br>

<h1 name="Escalada">5. Escalada de privilegios a Root</h1>

Una vez hemos accedido con el usuario de Francisca deberemos buscar alguna vulnerabilidad que nos permita acceder como root, para ello realizaremos una búsqueda de los archivos y directorios que formen parte de dbadmin que es el grupo en el que esta Francisca. 

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/find_dbadmin.png" alt="Find dbadmin">

Encontramos los directorios ya vistos anteriormente y lo que parece ser un programa en /bin llamada backupdb.
Después de probar el programa podemos ver que nos crea un directorio en una ruta desconocida y que nos muestra las **primeras lineas** del archivo creado, esto nos daría a entender que el comando utilizado para leer el archivo sera **head**.

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/prueba_backupdb.png" alt="Prueba backupdb">

Revisando los permisos vemos que tiene el permiso SUID es en el usuario, esto nos permitirá ejecutar el programa con los permisos del usuario en este caso root.

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ls_backupdb.png" alt="ls backupdb">

Para poder aprovecharnos de que el programa tiene el permiso SUID realizaremos path hijacking para que cuando el programa ejecute la instrucción **head** en vez de realizar la lectura del archivo abra una nueva shell. Para ello crearemos un archivo llamado head que invoque un shell bash. 

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/ls_head.png" alt="ls head">

Para realizar el path hijacking deberemos cambiar la variable de entorno **PATH** para que apunte hacia el directorio **/tmp** que es donde tenemos nuestro archivo **head**.
Una vez realizado el path hijacking, cuando ejecutemos el programa **backupdb** y se llame a la instrucción head se abrirá una shell como el usuario root, ya que se ha llamado a nuestro head falso utilizando los permisos del propietario.

<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/path_hijacking.png" alt="Path Hijacking">

<br>

<h1 name="flag-root">6. Flag de Root</h1>
Cuando hayamos accededido como root nos dirijiremos al directiorio **/root**. Despues de analizar varios directorios encontramos la flag en <strong>bash_history</strong> <br>
<img src="https://github.com/Dani-ITB24/Proyecto-Final/raw/Grupo5(Eloi-Alan-Fernando-Jose-Zome%C3%B1o)/Assets/Img/root_flag.png" alt="Flag en el directorio build">
